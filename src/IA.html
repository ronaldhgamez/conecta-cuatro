<!DOCTYPE html>
<html>
<title>Web Page Design</title>
<head>
<script>

var matrix = [
    0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,
    0,0,0,2,0,0,0,
    0,0,0,1,0,1,0,
    1,2,0,1,0,2,0,
    2,1,1,1,2,1,0
];

var n = 7;

function isInitialMove(color) {
    var size = matrix.length;
    for (var i=(size-1); i >= 0; i--) {
        // There are one file already
        if (matrix[i] == color) {
            return false;
        }
    }
    return true;
}

// Retorna un entero aleatorio entre min (incluido) y max (excluido)
// ¡Usando Math.round() te dará una distribución no-uniforme!
function getRandomInt(min, max) {
    var random;
    do {
        random = Math.floor(Math.random() * (max - min)) + min;
    } while (matrix[random] != 0);
    return random;
}

function addToObject(dict, e) {
    if (dict.hasOwnProperty(e)) {
        dict[e] += 1;
    } else {
        dict[e] = 1;
    }
    return dict;
}

function printObject(dict) {
    document.write(JSON.stringify(dict, null, 4));
    console.log(JSON.stringify(dict, null, 4));
}

function verticalMoves(rivalColor) {
    var winMoves = {};
    //document.write("<br>Vertical");
    var c = 0;

    // 
    for (var i=(matrix.length - 1); i >= (matrix.length - n); i--) {
        let j = i;
        let count = 0;
        // mientras no se salga y sea del mismo color
        while((j - n) >= 0 && matrix[j] != 0) {
            
            if (matrix[j] == rivalColor) {
                count += 1;
            } else {
                count = 0;
            }
            
            j -= n;
            
            if (count >= 3 && matrix[j] == 0) {
                //document.write("<br>[win i: " + j + "]");
                winMoves = addToObject(winMoves, j); // añade indice al gane
            }
        }
    }
    return winMoves;
}

// falta cuando la matriz está algo así: 0,1,1,0,1
// solo valida que hayan tres 1 seguidos
function horizontalMoves(rivalColor) {
    var winMoves = {};
    
    var c = 0;
    //document.write("<br><br>Horizontal")
    // LINEA A LINEA
    for (var i=(matrix.length - 1); i >= (n - 1); i-=n) {
        //document.write(" i: " + i);
        
        
        let j = i;
        let count = 0;
        //document.write(" {");
        // mientras no se salga y sea del mismo color
        while((i - (n - 1)) >= 0 && j != (i-n)) {
            //document.write(j + ", ");
            
            if (matrix[j] == rivalColor) {
                count += 1;
            } else {
                count = 0;
            }
            
            j--;
            
            // para validar si puede ganar por ambos lados
            if (count == 3) {
                // puede ganar por la derecha? valida extremo derecho
                if (j + 3 <= i) {
                    // caso gana por la derecha en la última fila
                    if (i == (matrix.length - 1) && matrix[j+4] == 0) {
                        //document.write("<br>[win: " + (j+4) + "]");
                        winMoves = addToObject(winMoves, (j+4)); // añade indice al gane
                    }
                    
                    // caso gana por la derecha demás filas (valida que la columna de abajo tenga ficha)
                    else if (matrix[j+4] == 0 && matrix[j + 4 + n] != 0) { // caso demás filas
                        //document.write("<br>[win: " + (j + 4) + "]");
                        winMoves = addToObject(winMoves, (j+4)); // añade indice al gane
                    }
                }
                
                // puede ganar por la izquierda? valida extremo izquierdo que no se pase
                if (j >= (i - (n - 1))) {
                    // caso gana por la izquierda en la última fila
                    if (i == (matrix.length - 1) && matrix[j] == 0) {
                        //document.write("<br>[win: " + j + "]");
                        winMoves = addToObject(winMoves, j); // añade indice al gane
                    }
                    
                    // caso gana izquierda demás filas (valida que la columna de abajo tenga ficha)
                    else if (matrix[j] == 0 && matrix[j + n] != 0) { // caso demás filas
                        //document.write("<br>[win: " + j + "]");
                        winMoves = addToObject(winMoves, j); // añade indice al gane
                    }
                }
                count = 0;
            }
            
        }
    }
    
    return winMoves;
}


function diagonalMoves(rivalColor) {
    var winMoves = {};

    return winMoves;
}

// Returns {} if the opposing opponent has no move
// or returns the indexes to block the rival
function searchWinMoves(color) {
    
    // object of index in where the opponent can win
    var winMoves = {};

    // VERTICAL MOVES
    var arrayIndexWin = verticalMoves(color);
    if (Object.keys(arrayIndexWin).length > 0) {
        // Merge Objects: add the posibles moves to winMoves
        winMoves = Object.assign(winMoves, arrayIndexWin);
    }   
    
    // HORIZONTAL MOVES
    arrayIndexWin = horizontalMoves(color);
    if (Object.keys(arrayIndexWin).length > 0) {
        // Merge Objects: add the posibles moves to winMoves
        winMoves = Object.assign(winMoves, arrayIndexWin);
    }
    
    // DIAGONAL MOVES
    arrayIndexWin = diagonalMoves(color);
    if (Object.keys(arrayIndexWin).length > 0) {
        // Merge Objects: add the posibles moves to winMoves
        winMoves = Object.assign(winMoves, arrayIndexWin);
    }
    return winMoves;
}

// es innecesaria??
function bestOptionToWin(winMoves) {
    // buscar el indice apropiado
    var index = -1;
    var total = 0; // veces que puede ganar con ese indice
    for(var key in winMoves) {
        if (winMoves[key] > total) {
            total = winMoves[key];
            index = parseInt(key);
        }
    }
    return index;
}

function allPosiblesIndex() {
    var indexes = [];
    for (var i=(matrix.length - 1); i >= (matrix.length - n); i--) {
        let j = i;
        // mientras no se salga y sea del mismo color
        while(j >= 0) {
            if (matrix[j] == 0) {
                indexes.push(j); // add posible index
                break;
            }
            j -= n;
        }
    }
    return indexes;
}


// retorna indice del indice del tablero donde tiene mas chance de ganar
// se puede armar jugada de gane? (tres fichas y una vacia)
function simulatePosiblesMoves(cpuColor) {
    
    // buscar todos los posibles indices donde se puede insertar ficha
    var indexes = allPosiblesIndex(); // [i, i, i, i]
    var size = indexes.length;

    var best = -1; // best index to move
    var times = -1; // total of times that the player can win
    
    // Simulate every posible index
    for(var i=0; i < size; i++) {
        matrix[indexes[i]] = cpuColor; // se simula poner fichas en los indices que se pueden
        //document.write("<br>-----------------------------<br>");
        //document.write("<br>simulating " + indexes[i] + "<br>");
        // once its simulate, it searches posibles wins
        var posiblesWin = searchWinMoves(cpuColor);
        
        if (Object.keys(posiblesWin).length > 0) {

            //document.write("<br><br>posibles win: ");
            printObject(posiblesWin);
            //document.write("<br>");

            var timesTemp = 0; // total times that can win
            for (var key in posiblesWin) {
                //document.write("<br>Can win in " + key + " " + posiblesWin[key] + " times <br>");
                timesTemp += posiblesWin[key];
            }
            //document.write("<br>total final times " + timesTemp + " <br>");
            
            if (timesTemp > times) {
                times = timesTemp;
                best = indexes[i];
                //document.write("<br> is better <br>");
            } else {
                //document.write("<br> but isn't better <br>");
            }

        } else{
            //document.write("<br> nothing <br>");
        }

        matrix[indexes[i]] = 0; // restablece a como estaba antes para
    }

    //document.write("<br>but the final best index is: " + best + "<br>");
    return best; // returns -1 if there is no options
}

// Validate if the index is a empty space and if has a checker below
function isEmptyAndValid(tempIndex) {
    return (matrix[tempIndex] == 0 && matrix[tempIndex + n] != 0) ? true : false;
}

// Receives an index and returns its neighboring indices vertically, 
// horizontally and diagonally.
function neighbors(index, color) {
    
    var neigborsIndeces = [];

    let row = Math.trunc(index / n); // Represents the index row
    
    //////////////// Vertical neighboring ////////////////
    if (row > 0) // First row does not count
        neigborsIndeces.push(index - 7);

    //////////////// Horizontal neighborings ////////////////
    
    let tempIndex = index - 1;
    let tempRow = Math.trunc(tempIndex / n);

    // To the left
    let shift = 2;
    while (row == tempRow && shift > 0) {
        // If found a blocking checker
        if (matrix[tempIndex] != 0 && matrix[tempIndex] != color)
            break;
        if (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color)
            neigborsIndeces.push(tempIndex);
    
        tempIndex--;
        tempRow = Math.trunc(tempIndex / n);    
        shift--;
    }
    // To the right
    tempIndex = index + 1;
    tempRow = Math.trunc(tempIndex / n);

    shift = 2;
    while (row == tempRow && shift > 0) {
        // If found a blocking checker
        if (matrix[tempIndex] != 0 && matrix[tempIndex] != color)
            break;
        if (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color)
            neigborsIndeces.push(tempIndex);
    
        tempIndex++;
        tempRow = Math.trunc(tempIndex / n);    
        shift--;
    }
    


    //////////////// Diagonal neighborings ////////////////

    // To the (index - (n - 1)) up/right
    let indexRow = Math.trunc(index / n);
    // Ignore column 0 and first row
    if (indexRow > 0 && index != (n * indexRow + (n - 1))) {
        tempIndex = index - (n - 1);
        let block = false;

        if (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color) {
            neigborsIndeces.push(tempIndex);
        } else {
            if (matrix[tempIndex] != 0)
                block = true;
        }

        indexRowAnt = Math.trunc(tempIndex / n);
        tempIndex = tempIndex - (n - 1);
        indexRowSig = Math.trunc(tempIndex / n);
        
        if (!block && (indexRowAnt != indexRowSig) && (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color)) {
            neigborsIndeces.push(tempIndex);
        }
    }

    // To the (index - (n + 1)) up/left
    indexRow = Math.trunc(index / n);
    // Ignore column 0 and first row
    if (indexRow > 0 && index != n * indexRow) {
        tempIndex = index - (n + 1);
        let block = false;

        if (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color) {
            neigborsIndeces.push(tempIndex);
        } else {
            if (matrix[tempIndex] != 0)
                block = true;
        }

        indexRowAnt = Math.trunc(tempIndex / n);
        tempIndex = tempIndex - (n + 1);
        indexRowSig = Math.trunc(tempIndex / n);
        
        if (!block && (indexRowAnt != indexRowSig) && (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color)) {
            neigborsIndeces.push(tempIndex);
        }
    }



    // To the (index + (n - 1)) down/left
    indexRow = Math.trunc(index / n);
    // Ignore column 0 and last row
    if (indexRow < (n-1) && index != n * indexRow) {  
        
        tempIndex = index + (n - 1);
        let block = false;

        if (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color) {
            neigborsIndeces.push(tempIndex);
        } else {
            if (matrix[tempIndex] != 0)
                block = true;
        }

        indexRowAnt = Math.trunc(tempIndex / n);
        tempIndex = tempIndex + (n - 1);
        indexRowSig = Math.trunc(tempIndex / n);
        
        if (!block && (indexRowAnt != indexRowSig) && (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color)) {
            neigborsIndeces.push(tempIndex);
        }
    }
 


    // To the (index + (n + 1)) down/right
    // raro el 26  
    indexRow = Math.trunc(index / n);
    // Ignore column (n - 1) and last row
    if (indexRow < (n-1) && index != (n * indexRow + (n - 1))) {
        
        tempIndex = index + (n + 1);
        let block = false;

        if (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color) {
            neigborsIndeces.push(tempIndex);
        } else {
            if (matrix[tempIndex] != 0)
                block = true;
        }
        indexRowAnt = Math.trunc(tempIndex / n);
        tempIndex = tempIndex + (n + 1);
        indexRowSig = Math.trunc(tempIndex / n);
        
        if (!block && (indexRowAnt != indexRowSig) && (isEmptyAndValid(tempIndex) || matrix[tempIndex] == color)) {
            neigborsIndeces.push(tempIndex);
        }
    }

    return neigborsIndeces;
}

function allNeighbors() {
    var a = allPosiblesIndex();
    for (var i=0; i < a.length; i++) {
        // amarrillo
        var n1 = neighbors(a[i], 1);
        // rojo
        var n2 = neighbors(a[i], 2);
        console.log("vecinos de amarillo, indice: " + a[i]);
        console.log(n1);
        console.log("vecinos de rojo, indice: " + a[i]);
        console.log(n2);
    }
}

function nextMove(cpuColor) {
    // la idea sería hacer jugadas dobles
    
    // se puede armar jugada de gane? (tres fichas y una vacia)
    var index = simulatePosiblesMoves(cpuColor);
    if (index != -1) {
        return index;
    }

    // armar jugada de dos (dos fichas )
    
    return -4;
}

// 
function CPU_IA(cpuColor, rivalColor) {

    // INITIAL MOVE
    if(isInitialMove(cpuColor) == true) {
        return getRandomInt((n * n - n), (n * n)); // random index choice
    }

    // VERIFIES IF CPU CAN WIN
    var winMoves = {};
    winMoves = searchWinMoves(cpuColor);
    if (Object.keys(winMoves).length > 0) {
        return bestOptionToWin(winMoves);
    }

    // TO BLOCK OPPONENT MOVES
    winMoves = searchWinMoves(rivalColor);
    if (Object.keys(winMoves).length > 0) {
        return bestOptionToWin(winMoves);
    }

    // TO SEARCH NEXT MOVE
    return nextMove(cpuColor);
}

function printMatrix() {
    var c = 0;
    for (var i=0; i<matrix.length; i++) {;
        text = matrix[i] + "  |  ";
        
        //document.getElementById("demo").innerHTML = ;
        document.write(text);

        c++;
        if(c==n) {
            document.write("<br>");
            c=0;
        }
    }

    document.write("<br>");
}
// 1: amarillo
// 2: rojo
// buscar movimiento siguiente
// 0. si no hay fichas tirar al azar
// 0.1 VERIFICA SI TIENE MOVIMIENTOS DE GANE
// 1. buscar jugadas enemigas(INDICE) (falta diagonal)
// 1.2. si las hay bloquear la mejor

// 2. buscar posición para jugar (next move)
// 3. Validar si esa posicion le da gane al contrario
// 3.1 si si: buscar otra jugada
// 3.2 si no: retornar indice

var turn = 1;

function makeMove() {
    
    var contrario;
    var index;
    var ant = turn;

    if (turn==1){
        index = CPU_IA(turn, 2);
        matrix[index] = turn;
    }else{
        index = CPU_IA(turn, 1);
        matrix[index] = turn;
    }

    turn = (turn == 1) ? 2 : 1;

    printMatrix();
    return "Se tiró ficha " + ant + " en indice " + index;
    
}

</script>
</head>
<body>

</body>
</html>